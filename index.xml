<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Julan&#39;s Blog</title>
    <link>https://example.com/</link>
    <description>Recent content on Julan&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 24 Apr 2021 00:13:24 +0800</lastBuildDate><atom:link href="https://example.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
    <title>IPC</title>
    <link>https://example.com/posts/os/ipc/</link>
    <pubDate>Sat, 24 Apr 2021 00:13:24 +0800</pubDate>
    
    <guid>https://example.com/posts/os/ipc/</guid>
    <description>
        &lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;进程间通信 (Inter-process Communication, IPC)&lt;/strong&gt;: 两个(或多个)不同的进程，通过内核或其他共享资源进行通信，来传递控制信息或数据。
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124736.png&#34; alt=&#34;300&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;直接通信和间接通信&#34;&gt;直接通信和间接通信&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接通信：基于共享内存&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;基于共享内存的消息传递核心抽象仍然是消息，而直接使用共享内存则不存在消息的抽象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;间接通信：基于操作系统内核，每次发送消息经过一个信箱
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124737.png&#34; alt=&#34;300&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;消息传递的同步与异步&#34;&gt;消息传递的同步与异步&lt;/h2&gt;
&lt;p&gt;消息可以是阻塞的也可以是非阻塞的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞通常被认为是同步通信，发送者/接收者一直处于阻塞状态，直到消息发出/到来。&lt;/li&gt;
&lt;li&gt;非阻塞通常被认为是异步通信，发送者/接收者不等待操作结果，直接返回。
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124738.png&#34; alt=&#34;300&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;管道&#34;&gt;管道&lt;/h1&gt;
&lt;p&gt;管道(Pipe)：a communication medium between two or more related or interrelated processes.
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124739.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;间接消息传递方式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单向的IPC&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;数据类型：字节流&lt;/li&gt;
&lt;li&gt;分为&lt;a href=&#34;#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93&#34;&gt;匿名管道&lt;/a&gt;和&lt;a href=&#34;#%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93&#34;&gt;命名管道&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如常见的Shell命令：&lt;code&gt;ls | grep&lt;/code&gt;
缺陷：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;固定的缓冲区间，分配过大资源容易造成浪费&lt;/li&gt;
&lt;li&gt;两个端口，最多对应两个进程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;匿名管道&#34;&gt;匿名管道&lt;/h2&gt;
&lt;p&gt;通常用于建立&lt;strong&gt;父子进程&lt;/strong&gt;或者&lt;strong&gt;兄弟进程&lt;/strong&gt;的连接，在创建的同时进程会拿到两个文件描述符用来使用它。
管道是通过调用** pipe** 函数创建的，fd[0] 用于读，fd[1] 用于写:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;pipe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;父进程首先通过pipe创建对应的管道的两端，然后通过fork创建子进程，子进程继承包括管道端口的&lt;strong&gt;文件描述符&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在完成继承后，父子进程关闭多余的端口。
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124740.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;命名管道&#34;&gt;命名管道&lt;/h2&gt;
&lt;p&gt;命名管道可以实现任意两个进程的通信，也称为&lt;strong&gt;FIFO&lt;/strong&gt;。
通过&lt;strong&gt;mkfifo&lt;/strong&gt;命令创建，指定一个&lt;strong&gt;全局的文件名&lt;/strong&gt;为管道名。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mkfifo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mode_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mkfifoat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mode_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;FIFO 常用于&lt;strong&gt;客户-服务器应用程序&lt;/strong&gt;中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。
&lt;img src=&#34;Pasted%20image%2020210418202912.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;消息队列&#34;&gt;消息队列&lt;/h1&gt;
&lt;p&gt;消息队列: 以链表的方式组织&lt;strong&gt;消息&lt;/strong&gt;(类型 + 数据)。
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124741.png&#34; alt=&#34;&#34;&gt;
基本遵循FIFO (First-In-First-Out)先进先出原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;消息队列的组织&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本遵循FIFO (First-In-First-Out)先进先出原则&lt;/li&gt;
&lt;li&gt;消息队列的写入：增加在队列尾部&lt;/li&gt;
&lt;li&gt;消息队列的读取：默认从队首获取消息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;允许按照类型查询: Recv(A, &lt;strong&gt;type&lt;/strong&gt;, message)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型为0时返回第一个消息 (FIFO)&lt;/li&gt;
&lt;li&gt;类型有值时按照类型查询并返回第一个类型为type的消息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息队列可以独立于读写进程存在，并允许任意数量的进程连接到统一队列上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;信号量&#34;&gt;信号量&lt;/h1&gt;
&lt;p&gt;信号量一般来说只有一个共享的整型&lt;strong&gt;计数器&lt;/strong&gt;，该计数器由内核维护和操作，通常用于&lt;a href=&#34;%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD.md&#34;&gt;同步原语&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&#34;共享内存&#34;&gt;共享内存&lt;/h1&gt;
&lt;p&gt;系统内核为两个进程映射&lt;strong&gt;共同的内存区域&lt;/strong&gt;。
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124742.png&#34; alt=&#34;&#34;&gt;
特点：数据不需要在进程之间复制，是&lt;strong&gt;速度最快&lt;/strong&gt;的 IPC。但需要使用&lt;a href=&#34;#%E4%BF%A1%E5%8F%B7%E9%87%8F&#34;&gt;信号量&lt;/a&gt;等同步机制。&lt;/p&gt;
&lt;h1 id=&#34;套接字&#34;&gt;套接字&lt;/h1&gt;
&lt;p&gt;套接字(Socket)用于不同机器间的进程通信。一般处于计算机网络中的&lt;a href=&#34;../Net/%E4%BC%A0%E8%BE%93%E5%B1%82.md&#34;&gt;传输层&lt;/a&gt;。&lt;/p&gt;

    </description>
    </item>
    
    <item>
    <title>内存管理</title>
    <link>https://example.com/posts/os/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
    <pubDate>Sat, 24 Apr 2021 00:13:24 +0800</pubDate>
    
    <guid>https://example.com/posts/os/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
    <description>
        &lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;虚拟内存： 为了让不同的应用程序&lt;strong&gt;高效安全&lt;/strong&gt;地使用物理内存资源，加入一个在&lt;strong&gt;应用程序&lt;/strong&gt;与&lt;strong&gt;物理内存&lt;/strong&gt;之间的抽象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高效性：虚拟内存抽象下，&lt;strong&gt;程序&lt;/strong&gt;使用虚拟地址访问主存，不会造成明显的性能开销。&lt;/li&gt;
&lt;li&gt;安全性：每个应用程序拥有&lt;strong&gt;独立&lt;/strong&gt;的虚拟地址空间，且只能访问属于自己的物理内存区域。
&lt;ul&gt;
&lt;li&gt;应用程序认为自己独占整个内存&lt;/li&gt;
&lt;li&gt;应用程序不再看到物理地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;地址翻译： 在程序执行过程中，CPU中的&lt;strong&gt;内存管理单元&lt;/strong&gt;（MMU, Memory Management Unit）会根据&lt;strong&gt;翻译规则&lt;/strong&gt;把虚拟地址转换成物理地址，然后通过物理地址访问物理内存。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;翻译规则取决于虚拟内存采用的组织机制，包括：分段机制和分页机制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124456.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;分段机制&#34;&gt;分段机制&lt;/h1&gt;
&lt;p&gt;虚拟地址空间分成若干个&lt;strong&gt;不同大小&lt;/strong&gt;的&lt;strong&gt;逻辑段&lt;/strong&gt;，如代码段、数据段等。&lt;/p&gt;
&lt;p&gt;翻译过程：
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124457.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MMU通过段表寄存器找到段表的位置，结合虚拟地址中的段号得到该段的起始地址（&lt;strong&gt;物理地址&lt;/strong&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;起始地址&lt;/strong&gt;加上虚拟地址中的&lt;strong&gt;段内偏移地址&lt;/strong&gt;得到最终的物理地址。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;存在问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分配的粒度太粗，容易导致物理内存上段与段之间留下&lt;strong&gt;碎片空间&lt;/strong&gt;，不足以映射虚拟地址空间的段，&lt;strong&gt;降低主存利用率&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此Intel在x86-64架构之后，&lt;a href=&#34;#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6&#34;&gt;分页机制&lt;/a&gt;成为主流。&lt;/p&gt;
&lt;h1 id=&#34;分页机制&#34;&gt;分页机制&lt;/h1&gt;
&lt;p&gt;分页机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;虚拟内存&lt;/strong&gt;划分成&lt;strong&gt;连续的、等长的虚拟页&lt;/strong&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124458.png&#34; alt=&#34;100&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;物理内存&lt;/strong&gt;也划分成&lt;strong&gt;连续的、等长的物理页&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;虚拟页和物理页&lt;strong&gt;页长固定&lt;/strong&gt;且&lt;strong&gt;相等&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;虚拟地址 = &lt;strong&gt;虚拟页号&lt;/strong&gt;+&lt;strong&gt;页内偏移&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;页表：包含多个页表项，&lt;strong&gt;存储虚拟页到物理页的映射&lt;/strong&gt;，分页机制的核心数据结构。&lt;/p&gt;
&lt;p&gt;翻译过程（和分段机制的翻译过程类似）：
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124459.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MMU解析虚拟地址中的&lt;strong&gt;虚拟页号&lt;/strong&gt;，通过虚拟页号找到该进程的&lt;strong&gt;页表&lt;/strong&gt;，得到物理页号。&lt;/li&gt;
&lt;li&gt;根据物理页号对应的&lt;strong&gt;物理页起始地址&lt;/strong&gt;加上虚拟地址中的&lt;strong&gt;页内偏移地址&lt;/strong&gt;得到最终的物理地址。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该机制实现了相比&lt;a href=&#34;#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6&#34;&gt;分段机制&lt;/a&gt;更细粒度的内存管理，大大缓解分段机制中常见的外部碎片。&lt;/p&gt;
&lt;h2 id=&#34;多级页表&#34;&gt;多级页表&lt;/h2&gt;
&lt;p&gt;使用多级页表可以减少空间占用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若某级页表中的某条目为空，那么对应的下一级页表无需存在&lt;/li&gt;
&lt;li&gt;实际应用的虚拟地址空间大部分都未被使用，因此无需分配页表&lt;/li&gt;
&lt;li&gt;减少空间的原因：允许页表中出现&amp;quot;空洞&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124500.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;tlb&#34;&gt;TLB&lt;/h2&gt;
&lt;p&gt;TLB:Translation Lookaside Buffer，起到类似于cache的作用，缓存了虚拟页号到物理页号的映射关系。
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124501.png&#34; alt=&#34;&#34;&gt;
在地址翻译过程中，MMU首先查询TLB：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TLB命中，则不再查询页表（fastpath）&lt;/li&gt;
&lt;li&gt;TLB未命中，再查询页表&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;切换页表时需要全部刷新TLB&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;换页机制&#34;&gt;换页机制&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;换页的基本思想
&lt;ul&gt;
&lt;li&gt;将物理内存里面存不下的内容放到&lt;strong&gt;磁盘&lt;/strong&gt;上&lt;/li&gt;
&lt;li&gt;虚拟内存使用不受物理内存大小限制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如何实现Swap
&lt;ul&gt;
&lt;li&gt;磁盘上划分专门的&lt;strong&gt;Swap&lt;/strong&gt;分区&lt;/li&gt;
&lt;li&gt;在处理&lt;strong&gt;缺页异常&lt;/strong&gt;时，触发物理内存页的换入换出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;页面置换算法&#34;&gt;页面置换算法&lt;/h2&gt;
&lt;h3 id=&#34;opt&#34;&gt;OPT&lt;/h3&gt;
&lt;p&gt;最佳(OPT, Optimal replacement algorithm)：所选择的被换出的页面将是==理论上==&lt;strong&gt;最长时间内不再被访问&lt;/strong&gt;，通常可以保证获得最低的缺页率。&lt;/p&gt;
&lt;h3 id=&#34;lru&#34;&gt;LRU&lt;/h3&gt;
&lt;p&gt;最近最久未使用(LRU, Least Recently Used)：将&lt;strong&gt;最近一次访问的时间最久&lt;/strong&gt;的页面替换出去。&lt;/p&gt;
&lt;h3 id=&#34;fifo&#34;&gt;FIFO&lt;/h3&gt;
&lt;p&gt;先进先出(FIFO, First In First Out)：将&lt;strong&gt;最先进入内存&lt;/strong&gt;的页面换出去。&lt;/p&gt;
&lt;h3 id=&#34;nru&#34;&gt;NRU&lt;/h3&gt;
&lt;p&gt;最近未使用(NRU, Not Recently Used)：
每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。
当发生缺页中断时，NRU 算法按如下&lt;strong&gt;顺序优先选择&lt;/strong&gt;如下状态的页面将其置换出去（相同状态下随机选择）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R=0，M=0&lt;/li&gt;
&lt;li&gt;R=0，M=1&lt;/li&gt;
&lt;li&gt;R=1，M=0&lt;/li&gt;
&lt;li&gt;R=1，M=1&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;可以看出，NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;clock&#34;&gt;Clock&lt;/h3&gt;
&lt;p&gt;时钟(Clock)：和&lt;a href=&#34;#NRU&#34;&gt;NRU&lt;/a&gt;类似，有一个状态位R，当页面被访问时设置页面的 R=1，同时定时清零R。
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124502.png&#34; alt=&#34;200&#34;&gt;
指针指向的页面若R=1则将指针向前移动一位（类似于时钟），直到找出R=0的页面将其替换出去。&lt;/p&gt;

    </description>
    </item>
    
    <item>
    <title>同步原语</title>
    <link>https://example.com/posts/os/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/</link>
    <pubDate>Sat, 24 Apr 2021 00:13:24 +0800</pubDate>
    
    <guid>https://example.com/posts/os/%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/</guid>
    <description>
        &lt;p&gt;在多道程序的环境下，存在着不同的制约关系，为了协调&lt;a href=&#34;%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B#%E8%BF%9B%E7%A8%8B&#34;&gt;进程&lt;/a&gt;间互相制约的关系，实现资源共享和进程协作，引入了进程同步。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;临界资源：只能同时被一个进程使用的资源。&lt;/li&gt;
&lt;li&gt;临界区 ：访问临界资源的代码段。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;同步机制的原则&#34;&gt;同步机制的原则&lt;/h1&gt;
&lt;h2 id=&#34;空闲让进&#34;&gt;空闲让进&lt;/h2&gt;
&lt;p&gt;当无进程处于临界区时，请求进入临界区的进程&lt;strong&gt;立即进入&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;忙则等待&#34;&gt;忙则等待&lt;/h2&gt;
&lt;p&gt;当有进程进入临界区时，其他要求访问临界资源的进程&lt;strong&gt;必须等待&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;有限等待&#34;&gt;有限等待&lt;/h2&gt;
&lt;p&gt;对要求访问临界资源的进程，保证能在&lt;strong&gt;有限时间&lt;/strong&gt;内进入临界区&lt;/p&gt;
&lt;h2 id=&#34;让权等待&#34;&gt;让权等待&lt;/h2&gt;
&lt;p&gt;当进程不能进入临界区时，应释放处理机&lt;/p&gt;

    </description>
    </item>
    
    <item>
    <title>死锁</title>
    <link>https://example.com/posts/os/%E6%AD%BB%E9%94%81/</link>
    <pubDate>Sat, 24 Apr 2021 00:13:24 +0800</pubDate>
    
    <guid>https://example.com/posts/os/%E6%AD%BB%E9%94%81/</guid>
    <description>
        &lt;p&gt;&lt;strong&gt;死锁(deadlock)&lt;/strong&gt;： 在&lt;a href=&#34;%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD.md&#34;&gt;同步原语&lt;/a&gt;的情况下，有一组线程因为组内所有线程都在等待组内其他线程释放资源而&lt;strong&gt;相互无限等待&lt;/strong&gt;的现象。
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124823.png&#34; alt=&#34;200&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;死锁产生的原因&#34;&gt;死锁产生的原因&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;互斥访问：资源只能最多被一个&lt;a href=&#34;%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B#%E7%BA%BF%E7%A8%8B&#34;&gt;线程&lt;/a&gt;持有。&lt;/li&gt;
&lt;li&gt;资源非抢占：资源只能由持有的&lt;a href=&#34;%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B#%E7%BA%BF%E7%A8%8B&#34;&gt;线程&lt;/a&gt;主动放弃，不能被其他线程抢占。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持有并等待&lt;/strong&gt;：&lt;a href=&#34;%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B#%E7%BA%BF%E7%A8%8B&#34;&gt;线程&lt;/a&gt;拥有一些资源并等待一些资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;循环等待&lt;/strong&gt;： 多个&lt;a href=&#34;%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B#%E7%BA%BF%E7%A8%8B&#34;&gt;线程&lt;/a&gt;形成一个循环，在该循环中每个线程都在等待下一个线程释放资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;死锁的检测与恢复&#34;&gt;死锁的检测与恢复&lt;/h1&gt;
&lt;p&gt;不试图阻止死锁，而是当检测到死锁发生时，由操作系统等第三者采取措施进行恢复。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;检测： 检测资源和线程形成的有向图是否形成环路，若有环路说明出现循环等待，即出现死锁。
&lt;img src=&#34;../pic/Pasted%20image%2020210420163413.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于一种资源可被多个线程占有的情况下，需要使用&lt;strong&gt;拓扑排序&lt;/strong&gt;算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;恢复&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接kill所有循环中的进程&lt;/li&gt;
&lt;li&gt;每次Kill一个线程，直到没有环&lt;/li&gt;
&lt;li&gt;线程全部&lt;strong&gt;回滚&lt;/strong&gt;到之前的某一状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;死锁预防&#34;&gt;死锁预防&lt;/h1&gt;
&lt;p&gt;在线程运行之前，破坏掉&lt;a href=&#34;#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0&#34;&gt;死锁产生的原因&lt;/a&gt;中的四个必要条件。&lt;/p&gt;
&lt;h2 id=&#34;避免互斥访问&#34;&gt;避免互斥访问&lt;/h2&gt;
&lt;p&gt;设计一个&lt;strong&gt;代理线程&lt;/strong&gt;专门管理对共享数据的访问与修改。
缺点：修改困难，且为系统带来多余负担。&lt;/p&gt;
&lt;h2 id=&#34;不允许持有并等待&#34;&gt;不允许持有并等待&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;一次性申请所有资源&lt;/strong&gt;，一旦有需要获取的资源被其他线程持有，则主动放弃之前已经持有的资源。
缺点：在资源竞争程度较高时，有可能出现持有-放弃的循环，即出现&lt;strong&gt;活锁&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;活锁：锁的竞争线程长时间无法进入临界区。
解决方法：线程在获取锁失败后等待随机时间再开始尝试，如&lt;a href=&#34;../Net/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.md#CSMA&#34;&gt;CSMA&lt;/a&gt;使用的二进制退避算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;允许资源被抢占&#34;&gt;允许资源被抢占&lt;/h2&gt;
&lt;p&gt;允许线程抢占已经被其他线程持有的资源。
缺点：需要保证被抢占的线程能够正确恢复，只适用于容易保存和恢复的场景。&lt;/p&gt;
&lt;h2 id=&#34;避免循环等待&#34;&gt;避免循环等待&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;所有资源进行编号&lt;/li&gt;
&lt;li&gt;所有进程递增获取&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;u&gt;任意时刻：获取最大资源号的进程可以继续执行，然后释放资源&lt;/u&gt;&lt;/p&gt;
&lt;h1 id=&#34;死锁避免&#34;&gt;死锁避免&lt;/h1&gt;
&lt;p&gt;当有资源需要分配时，&lt;strong&gt;系统&lt;/strong&gt;检查此次资源分配后是否处于&lt;strong&gt;安全状态&lt;/strong&gt;，只有处于安全状态才给线程该资源，否则阻塞进程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;安全状态：存在至少一个安全序列&amp;lt;P1,P2,…,Pn&amp;gt;，系统按照该序列调度线程执行即可避免死锁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;银行家算法&#34;&gt;银行家算法&lt;/h2&gt;

    </description>
    </item>
    
    <item>
    <title>进程与线程</title>
    <link>https://example.com/posts/os/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link>
    <pubDate>Sat, 24 Apr 2021 00:13:24 +0800</pubDate>
    
    <guid>https://example.com/posts/os/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid>
    <description>
        &lt;h1 id=&#34;进程&#34;&gt;进程&lt;/h1&gt;
&lt;p&gt;进程是计算机程序运行时的抽象。&lt;/p&gt;
&lt;h2 id=&#34;进程的状态&#34;&gt;进程的状态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;新生状态（ new ）：进程刚被创建&lt;/li&gt;
&lt;li&gt;运行状态（ running ）：进程正在处理器上运行&lt;/li&gt;
&lt;li&gt;准备状态（ ready ）：进程可以运行，但没有被调度&lt;/li&gt;
&lt;li&gt;阻塞状态（ blocked ）：进程进入等待状态，短时间不再运行&lt;/li&gt;
&lt;li&gt;终结状态（ terminated ）：进程完成了执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124847.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;地址空间&#34;&gt;地址空间&lt;/h2&gt;
&lt;p&gt;进程具有&lt;strong&gt;独立的虚拟地址空间&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个进程都具有&amp;quot;独占全部内存&amp;quot;的假象&lt;/li&gt;
&lt;li&gt;内核中同样包含内核栈和内核代码、数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124846.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进程是计算机程序运行时的抽象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态部分：程序运行需要的代码和数据&lt;/li&gt;
&lt;li&gt;动态部分：程序运行期间的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;进程控制块&#34;&gt;进程控制块&lt;/h2&gt;
&lt;p&gt;**Process Control Block（PCB）**是保存进程状态的数据结构，存放进程相关的各种信息，如进程的标识符（PID）、内存、打开的文件及进程在切换时的状态(&lt;a href=&#34;#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2&#34;&gt;上下文切换&lt;/a&gt;)
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124848.png&#34; alt=&#34;400&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;上下文切换&#34;&gt;上下文切换&lt;/h2&gt;
&lt;p&gt;进程的上下文包括进程运行时的&lt;strong&gt;寄存器状态&lt;/strong&gt;，用于&lt;strong&gt;保存&lt;/strong&gt;和&lt;strong&gt;恢复&lt;/strong&gt;一个进程在CPU上运行的状态。
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124849.png&#34; alt=&#34;200&#34;&gt;
当OS需要切换当前进程时，就会使用&lt;strong&gt;上下文切换（context switch）机制&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;进程的基本操作接口&#34;&gt;进程的基本操作接口&lt;/h2&gt;
&lt;p&gt;以下操作以Linux的进程操作为例。&lt;/p&gt;
&lt;h3 id=&#34;进程创建fork&#34;&gt;进程创建：fork()&lt;/h3&gt;
&lt;p&gt;fork()：为调用进程创建一个一模一样的新进程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用进程为父进程，新进程为子进程&lt;/li&gt;
&lt;li&gt;接口简单，无需任何参数&lt;/li&gt;
&lt;li&gt;fork后的两个进程均为独立进程，拥有不同的PID&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124850.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;fork为进程之间建立了父进程和子进程的关系
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124851.png&#34; alt=&#34;&#34;&gt;
多个进程可以属于同一个进程组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子进程默认与父进程属于同一个进程组&lt;/li&gt;
&lt;li&gt;可以向同一进程组中的所有进程发送信号&lt;/li&gt;
&lt;li&gt;主要用于shell程序中&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;进程的执行exec&#34;&gt;进程的执行：exec&lt;/h3&gt;
&lt;p&gt;在fork完成之后，在多数情况下需要子进程执行与父进程不同的任务。为了实现该目标，Linux提供了exec接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124853.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;线程&#34;&gt;线程&lt;/h1&gt;
&lt;p&gt;线程是OS&lt;strong&gt;资源分配和调度&lt;/strong&gt;的基本单位。&lt;/p&gt;
&lt;h2 id=&#34;为什么需要线程&#34;&gt;为什么需要线程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建进程的开销较大-包括了数据、代码、堆、栈等&lt;/li&gt;
&lt;li&gt;进程的隔离性过强：可以通过进程间通信（IPC），但开销较大&lt;/li&gt;
&lt;li&gt;进程内部无法支持并行&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多线程进程的地址空间&#34;&gt;多线程进程的地址空间&lt;/h2&gt;
&lt;p&gt;线程只包含&lt;strong&gt;运行时的状态&lt;/strong&gt;，静态部分由进程提供。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个线程包括了执行所需的最小状态（主要是寄存器和栈）&lt;/li&gt;
&lt;li&gt;其它区域共享：	数据、代码、堆……&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程模型&#34;&gt;线程模型&lt;/h2&gt;
&lt;p&gt;根据线程是否受内核管理，可以将线程分为两类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核态线程：由内核创建及管理，线程相关信息存放在内核中&lt;/li&gt;
&lt;li&gt;用户态线程（&lt;strong&gt;纤程&lt;/strong&gt;）：不受内核直接管理，在应用态创建，线程相关信息主要存放在应用数据中&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;线程模型&lt;/strong&gt;会建立用户态线程与内核态线程之间的联系。这种联系可分为&lt;a href=&#34;#%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B&#34;&gt;多对一模型&lt;/a&gt;、&lt;a href=&#34;#%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B&#34;&gt;一对一模型&lt;/a&gt;和&lt;a href=&#34;#%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B&#34;&gt;多对多模型&lt;/a&gt;。&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124852.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;多对一模型&#34;&gt;多对一模型&lt;/h3&gt;
&lt;p&gt;将多个用户态线程映射给单一的内核线程。内核管理简单但可扩展性差，无法适应多核机器的发展。&lt;/p&gt;
&lt;p&gt;用途：在主流操作系统中被弃用，用于各种&lt;strong&gt;用户态线程库&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;一对一模型&#34;&gt;一对一模型&lt;/h3&gt;
&lt;p&gt;每个用户线程映射单独的内核线程。解决了&lt;a href=&#34;#%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B&#34;&gt;多对一模型&lt;/a&gt;中的可扩展性问题，但内核线程数量大，开销大。&lt;/p&gt;
&lt;p&gt;用途：主流操作系统都采用一对一模型，如Windows、Linux。&lt;/p&gt;
&lt;h3 id=&#34;多对多模型&#34;&gt;多对多模型&lt;/h3&gt;
&lt;p&gt;多对多模型（又叫Scheduler Activation）：N个用户态线程映射到M个内核态线程（N &amp;gt; M）。解决了&lt;a href=&#34;#%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B&#34;&gt;多对一模型&lt;/a&gt;中的可扩展性问题和&lt;a href=&#34;#%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B&#34;&gt;一对一模型&lt;/a&gt;的线程过多问题，但管理变得更为复杂。
用途：在虚拟化中得到了广泛应用。&lt;/p&gt;
&lt;h2 id=&#34;线程控制块&#34;&gt;线程控制块&lt;/h2&gt;
&lt;p&gt;线程控制块TCB和&lt;a href=&#34;#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97&#34;&gt;进程控制块&lt;/a&gt;类似，对于&lt;a href=&#34;#%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B&#34;&gt;一对一模型&lt;/a&gt;的TCB可以分成两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核态：与PCB结构类似&lt;/li&gt;
&lt;li&gt;应用态：主要由线程库定义，可以认为是内核TCB的扩展&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;ChCore的TCB结构:
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124855.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;线程本地存储&#34;&gt;线程本地存储&lt;/h2&gt;
&lt;p&gt;问题：对于全局变量，不同线程可能需要不同的拷贝
解决方法：线程本地存储（Thread Local Storage， TLS）&lt;/p&gt;
&lt;p&gt;线程本地存储用于保存线程自身相关的信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例：__thread int id; 会为每个线程定义一个独有的id变量
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124856.png&#34; alt=&#34;&#34;&gt;
TLS寻址模式：基地址＋偏移量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;进程和线程的区别&#34;&gt;进程和线程的区别&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;拥有资源：进程是资源分配的基本单位；而线程基本不拥有资源，共享进程的地址空间，即访问隶属进程的资源&lt;/li&gt;
&lt;li&gt;调度：线程是OS调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。&lt;/li&gt;
&lt;li&gt;系统开销：创建或撤销进程的&lt;a href=&#34;#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97&#34;&gt;进程控制块&lt;/a&gt;所付出的开销远大于创建或撤销线程的&lt;a href=&#34;#%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97&#34;&gt;线程控制块&lt;/a&gt;的开销。在进行上下文切换时，进程的上下文远比线程的上下文的内容多，付出的开销也更大。&lt;/li&gt;
&lt;li&gt;通信：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要通过进程间通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;纤程&#34;&gt;纤程&lt;/h1&gt;
&lt;p&gt;纤程（fiber）可以认为是&lt;strong&gt;用户态线程&lt;/strong&gt;。一个内核线程可以对应多个纤程，即&lt;a href=&#34;#%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B&#34;&gt;多对一模型&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124857.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要创建内核线程，开销更小&lt;/li&gt;
&lt;li&gt;上下文切换不需要进入内核，切换快&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;u&gt;核心：把OS的内核调度器的调度权让给应用程序，有助于做出更优的调度决策。&lt;/u&gt;&lt;/p&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://ipads.se.sjtu.edu.cn/courses/os/2020/schedule.shtml&#34;&gt;上海交通大学SE-315 · 操作系统（2020春)&lt;/a&gt;&lt;/p&gt;

    </description>
    </item>
    
    <item>
    <title>进程调度</title>
    <link>https://example.com/posts/os/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</link>
    <pubDate>Sat, 24 Apr 2021 00:13:24 +0800</pubDate>
    
    <guid>https://example.com/posts/os/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</guid>
    <description>
        &lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/Pasted%20image%2020210416211921.png&#34; alt=&#34;&#34;&gt;
为了在有限的资源下通过对多个程序执行过程的管理，满足系统和应用的指标，调度器需要对&lt;a href=&#34;%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B#%E7%BA%BF%E7%A8%8B&#34;&gt;线程&lt;/a&gt;进行调度(Scheduling)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线程是调度器的调度对象，但在Linux等OS常用任务(job/task)描述线程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;执行结束条件&#34;&gt;执行结束条件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;时间片结束&lt;/li&gt;
&lt;li&gt;出现I/O请求&lt;/li&gt;
&lt;li&gt;主动停止或进入睡眠&lt;/li&gt;
&lt;li&gt;被系统打断（抢占式调度）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;调度决策&#34;&gt;调度决策&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;下一个执行的任务&lt;/li&gt;
&lt;li&gt;执行该任务的CPU核心&lt;/li&gt;
&lt;li&gt;执行的时长，即时间片&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;调度指标&#34;&gt;调度指标&lt;/h2&gt;
&lt;p&gt;Scheduling Criteria（调度指标）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;周转时间&lt;/strong&gt;：任务第一次进入系统到执行结束的时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;响应时间&lt;/strong&gt;：任务第一次进入系统到第一次给用户输出的时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实时性&lt;/strong&gt;：在任务的截止时间内完成任务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;公平性&lt;/strong&gt;：每个任务都应该有机会执行，不能饿死&lt;/li&gt;
&lt;li&gt;吞吐率：单位时间内处理的任务数量&lt;/li&gt;
&lt;li&gt;开销低：调度器是为了优化系统，而非制造性能BUG&lt;/li&gt;
&lt;li&gt;可扩展：随着任务数量增加，仍能正常工作&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;调度的挑战&#34;&gt;调度的挑战&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;缺少信息&lt;/li&gt;
&lt;li&gt;线程/任务间的复杂交互&lt;/li&gt;
&lt;li&gt;调度目标多样性：不同的系统可能关注不一样的&lt;a href=&#34;%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6.md#%E8%B0%83%E5%BA%A6%E6%8C%87%E6%A0%87&#34;&gt;调度指标&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;三级调度&#34;&gt;三级调度&lt;/h1&gt;
&lt;p&gt;进程调度可以分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Long-Term Scheduler&lt;/li&gt;
&lt;li&gt;Short-Term Scheduler&lt;/li&gt;
&lt;li&gt;Medium-Term Scheduler&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/Pasted%20image%2020210417154022.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;long-term-scheduler&#34;&gt;Long-Term Scheduler&lt;/h2&gt;
&lt;p&gt;也称为 job scheduler.
goal: &lt;strong&gt;regulates the program and select process from the queue and loads them into memory for execution.&lt;/strong&gt;
负责将处于新生状态的进程转为就绪状态，限制系统被短期调度管理的进程数量。&lt;/p&gt;
&lt;h2 id=&#34;short-term-scheduler&#34;&gt;Short-Term Scheduler&lt;/h2&gt;
&lt;p&gt;也称为 CPU scheduler.
goal:This helps you to select from a group of processes that are ready to execute and allocates CPU to one of them.
负责进程再就绪状态、运行状态和阻塞状态的转换。&lt;/p&gt;
&lt;h2 id=&#34;medium-term-scheduler&#34;&gt;Medium-Term Scheduler&lt;/h2&gt;
&lt;p&gt;中期调度是换页机制(swapping)的一部分，能够降低进程占用的内存。
机制：将被短期调度器管理的处于就绪状态或阻塞状态的进程挂起，转为挂起就绪状态或挂起阻塞状态，并在适当时机重新激活被挂机的进程。&lt;/p&gt;
&lt;h1 id=&#34;批处理任务调度&#34;&gt;批处理任务调度&lt;/h1&gt;
&lt;p&gt;批处理任务调度算法的关注指标主要是&lt;strong&gt;周转时间&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;fcfs&#34;&gt;FCFS&lt;/h2&gt;
&lt;p&gt;先到先得(First Come First Served, FCFS)，也称为先进先出(FIFO)策略。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特点：简单、直观，有利于长任务。&lt;/li&gt;
&lt;li&gt;问题： 平均周转周期长、响应时间长&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sjf&#34;&gt;SJF&lt;/h2&gt;
&lt;p&gt;最短任务优先(Shortest Job First, SJF)，该策略会选择&lt;strong&gt;运行时间最短&lt;/strong&gt;的任务执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特点：**平均周转时间短 **&lt;/li&gt;
&lt;li&gt;问题：
&lt;ul&gt;
&lt;li&gt;必须预知任务的运行时间&lt;/li&gt;
&lt;li&gt;严重依赖于任务到达时间点：若短任务迟来则不会执行（非抢占式调度）&lt;/li&gt;
&lt;li&gt;不公平，长任务容易饿死&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;stcf&#34;&gt;STCF&lt;/h2&gt;
&lt;p&gt;最短完成时间任务优先(Shortest Time-to-Completion First, STCF)，也称为最短剩余时间优先 shortest remaining time next（SRTN）。该策略会选择&lt;strong&gt;剩余运行时间最短&lt;/strong&gt;的任务执行，且为&lt;strong&gt;抢占式调度&lt;/strong&gt; (Preemptive Scheduling)，可以看出&lt;a href=&#34;%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6.md#SJF&#34;&gt;SJF&lt;/a&gt;的抢占式版本，解决了迟来的短任务无法受益问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;抢占式调度: 在任务到达系统时也会进行调度，有可能中断当前执行的任务转而执行其他任务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;特点：**平均周转时间短 **&lt;/li&gt;
&lt;li&gt;问题：不公平，长任务容易饿死&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;交互式任务调度&#34;&gt;交互式任务调度&lt;/h1&gt;
&lt;h2 id=&#34;rr&#34;&gt;RR&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间片轮转(Round Robin , RR)&lt;/strong&gt;：为了定时响应用户，为任务设置时间片，限定任务每次执行时间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特点：平均&lt;strong&gt;响应时间短&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;问题：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;周转时间长&lt;/strong&gt;，尤其是任务运行时间相似的场景&lt;/li&gt;
&lt;li&gt;需要选取时间片大小，且过小的时间片会引入大量调度器的&lt;strong&gt;调度开销&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;优先级调度&#34;&gt;优先级调度&lt;/h2&gt;
&lt;p&gt;通过为每个任务指定一个&lt;strong&gt;优先级(Priority)&lt;/strong&gt;，调度器坑确定哪些任务应该优先执行。&lt;u&gt;实际上，&lt;a href=&#34;%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6.md#FCFS&#34;&gt;FCFS&lt;/a&gt;、&lt;a href=&#34;%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6.md#STCF&#34;&gt;STCF&lt;/a&gt;、&lt;a href=&#34;%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6.md#STCF&#34;&gt;STCF&lt;/a&gt;、&lt;a href=&#34;%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6.md#RR&#34;&gt;RR&lt;/a&gt;也有优先级&lt;/u&gt;。
Multi-level Queue(多级队列)属于静态优先级调度策略，严重依赖于预设的优先级进行调度、&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提高I/O密集型任务的优先级，避免造成I/O利用率低下&lt;/li&gt;
&lt;li&gt;低优先级任务饥饿问题：需要为等待时间过长的任务提高优先级&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC&#34;&gt;优先级反转&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mlfq&#34;&gt;MLFQ&lt;/h2&gt;
&lt;p&gt;多级反馈队列(Multi-Level Feedback Queue, MLFQ)，属于经典的基于多级队列的动态&lt;a href=&#34;%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6.md#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6&#34;&gt;优先级调度&lt;/a&gt;。
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/Pasted%20image%2020210417155733.png&#34; alt=&#34;&#34;&gt;
we arrive at the first two basic rules for MLFQ:
• Rule 1: If Priority(A) &amp;gt; Priority(B), A runs (B doesn’t).
• Rule 2: If Priority(A) = Priority(B), A &amp;amp; B run in &lt;a href=&#34;#RR&#34;&gt;RR&lt;/a&gt;.优先级越低，时间片越长。
• Rule 3: When a job enters the system, it is placed at the highest priority (the topmost queue).
动态调节机制：
• &lt;strong&gt;Penaly&lt;/strong&gt;: If a job uses up an entire &lt;strong&gt;time slice while 					running&lt;/strong&gt;, its &lt;strong&gt;priority is reduced&lt;/strong&gt; (i.e., it moves down one queue).
• &lt;strong&gt;Boost&lt;/strong&gt;：&lt;strong&gt;After some time period&lt;/strong&gt; S, move all the jobs in the system to the &lt;strong&gt;topmost queue&lt;/strong&gt;.
Penaly可以提高短任务（同时包括I/O密集型任务）的优先级，从而提高平均周转时间。
Boost可以防止长任务饥饿。
问题：需要调整许多参数，如优先级队列的数量、时间片大小及最大运行时间，Boost的周期等等。&lt;/p&gt;
&lt;h1 id=&#34;公平共享调度&#34;&gt;公平共享调度&lt;/h1&gt;
&lt;p&gt;公平共享调度（Fair-Share Scheduling）考虑用户占用的资源比例：用&lt;strong&gt;份额&lt;/strong&gt;（share）量化每个任务对CPU时间的使用，明确任务应该使用的&lt;strong&gt;系统资源比例&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Ticket Transfer:&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;lottery-scheduling&#34;&gt;Lottery Scheduling&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Lottery Scheduling（彩票调度）&lt;/strong&gt;：根据每个任务的份额比例分配每个任务的彩票数量，任务拥有的彩票数量越多，越有可能被调度：
每次调度根据生成随机数确定任务是否被调度。
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/Pasted%20image%2020210417160615.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ticket Transfer(彩票转让)：与优先级反转类似。
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/Pasted%20image%2020210417155347.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Lottery Scheduling的随机化实现简单，但会带来不确定性，在调度次数较少时将达不到预期效果（即频率和概率在次数较少的情况下下相差过大）。&lt;/p&gt;
&lt;h2 id=&#34;stride-scheduling&#34;&gt;Stride Scheduling&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Stride Scheduling(步幅调度)&lt;/strong&gt;：&lt;strong&gt;确定性&lt;/strong&gt;版本的&lt;a href=&#34;#Lottery%20Scheduling&#34;&gt;Lottery Scheduling&lt;/a&gt;，核心是&lt;strong&gt;步幅（Stride）&lt;/strong&gt;：任务一次执行增加的虚拟时间，和份额成反比。
机制：每次调度选择当前虚拟时间最小的任务调度并增加虚拟时间（即步幅）大小。
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/Pasted%20image%2020210420173316.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;新的任务进入时虚拟时间应该设置成当前所有任务的最小虚拟时间，防止新的任务长时间占有CPU。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;优先级反转&#34;&gt;优先级反转&lt;/h1&gt;
&lt;p&gt;线程执行顺序违反预先优先级。&lt;/p&gt;
&lt;h2 id=&#34;产生原因&#34;&gt;产生原因&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/Pasted%20image%2020210420183342.png&#34; alt=&#34;&#34;&gt;
高优先级A线程抢占了低优先级C线程并尝试获取被C线程持有的资源，导致A线程阻塞，另一个比A线程优先级低的线程B却可以正常执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统：基于优先级调度&lt;/li&gt;
&lt;li&gt;锁：按照锁使用的策略进行调度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;根本原因：双重调度不协调&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;
&lt;h3 id=&#34;不可打断临界区协议&#34;&gt;不可打断临界区协议&lt;/h3&gt;
&lt;p&gt;不可打断临界区协议(Non-preemptive Critical Sections, NCP)：进入临界区后不允许其他进程打断：禁止操作系统调度。&lt;/p&gt;
&lt;h3 id=&#34;优先级继承协议&#34;&gt;优先级继承协议&lt;/h3&gt;
&lt;p&gt;优先级继承协议(Priority Inheritance Protocol, PIP)：将被阻塞的高优先级任务的优先级转移给占用资源的低优先级任务。
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/Pasted%20image%2020210420172518.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;优先级置顶协议&#34;&gt;优先级置顶协议&lt;/h3&gt;
&lt;p&gt;优先级置顶协议(Priority Ceiling Protocols, PCP)：将获取锁的线程的优先级设置为该锁的所有竞争线程的最高优先级。
根据获取锁的时间分类，该协议可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;即时优先级置顶协议(Immediate Priority Ceiling Protocols, IPCP)：在获取锁后立刻提升优先级。
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/Pasted%20image%2020210417152449.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原生优先级置顶协议(Original Priority Ceiling Protocols, OPCP)：在检测到高优先级竞争该锁时再提升优先级。
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/Pasted%20image%2020210420183357.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;实时调度&#34;&gt;实时调度&lt;/h1&gt;
&lt;p&gt;对于&lt;strong&gt;周期任务&lt;/strong&gt;，主要有两种调度算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;速率单调&lt;/li&gt;
&lt;li&gt;最早截止时间优先&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;速率单调&#34;&gt;速率单调&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;速率单调（Rate-Monotonic, RM）&lt;/strong&gt;：&lt;strong&gt;速率&lt;/strong&gt;越高，则优先级越高。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;速率：任务周期的倒数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在基于静态优先级的实时调度策略中，RM策略是最优的。但在一组任务的CPU利用率U不大于1的情况下，不一定能够满足这组任务的截止时间要求。&lt;/p&gt;
&lt;h2 id=&#34;最早截止时间优先&#34;&gt;最早截止时间优先&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;最早截止时间优先(Earliest Deadline First, EDF)&lt;/strong&gt;：根据任务的&lt;strong&gt;截止时间&lt;/strong&gt;动态调整任务的优先级。
在CPU利用率U不大于1的情况下，EDF一定能够满足这组任务的截止时间要求，是在U不大于1的情况下的最优实时调度策略。
若U大于1，则会引发多米诺效应：EDF没有任务的运行时间信息，无法提前拒绝任务，也没有中断机制调度其他任务。&lt;/p&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched-mlfq.pdf&#34;&gt;Multilevel Feedback Queues (MLFQ) - LASS-PDF&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ipads.se.sjtu.edu.cn/courses/os/2020/schedule.shtml&#34;&gt;上海交通大学SE-315 · 操作系统（2020春)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

    </description>
    </item>
    
    <item>
    <title>传输层</title>
    <link>https://example.com/posts/net/%E4%BC%A0%E8%BE%93%E5%B1%82/</link>
    <pubDate>Thu, 22 Apr 2021 00:13:24 +0800</pubDate>
    
    <guid>https://example.com/posts/net/%E4%BC%A0%E8%BE%93%E5%B1%82/</guid>
    <description>
        &lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;传输层提供进程之间的逻辑通信服务。
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143031.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;port&#34;&gt;Port&lt;/h2&gt;
&lt;p&gt;Port(端口)：&lt;strong&gt;区分每个&lt;a href=&#34;../OS/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E8%BF%9B%E7%A8%8B&#34;&gt;进程&lt;/a&gt;的标识符&lt;/strong&gt;，1个端口号使用16位无符号整数（unsigned integer）来表示。&lt;a href=&#34;#TCP&#34;&gt;TCP&lt;/a&gt;和&lt;a href=&#34;#UDP&#34;&gt;UDP&lt;/a&gt;是互相独立的，因此TCP和UDP都各拥有65535个端口。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1&amp;ndash;1023 系统保留，只能由root用户使用。&lt;/li&gt;
&lt;li&gt;1024&amp;mdash;4999 由客户端进程占有&lt;/li&gt;
&lt;li&gt;5000&amp;mdash;65535 由服务器端进程自由分配&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在&lt;a href=&#34;#UDP&#34;&gt;UDP&lt;/a&gt;中，源端口号可以选择要不要填上，如果设为0，则代表没有源端口号。&lt;/p&gt;
&lt;h2 id=&#34;tsap&#34;&gt;TSAP&lt;/h2&gt;
&lt;p&gt;TSAP(Transport Service Access Point) : 传输服务访问点,也称为传输层地址。
TSAP = &lt;a href=&#34;%E7%BD%91%E7%BB%9C%E5%B1%82.md#IP&#34;&gt;IP&lt;/a&gt; + &lt;a href=&#34;#Port&#34;&gt;Port&lt;/a&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143032.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;socket&#34;&gt;Socket&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;套接字（Socket）是为了使应用程序能够方便地使用协议栈软件进行通信的一种方法。&lt;/strong&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143033.png&#34; alt=&#34;&#34;&gt;
套接字上联==应用进程==，下联==网络协议栈==，是&lt;a href=&#34;../OS/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E8%BF%9B%E7%A8%8B&#34;&gt;进程&lt;/a&gt;通过网络协议栈进行通信的接口。
结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相关描述：{协议，本地&lt;a href=&#34;%E7%BD%91%E7%BB%9C%E5%B1%82.md#IP&#34;&gt;IP&lt;/a&gt;地址，本地端口&lt;a href=&#34;#Port&#34;&gt;Port&lt;/a&gt;}&lt;/li&gt;
&lt;li&gt;相关描述：{协议，本地地址，本地端口，&lt;strong&gt;远程地址，远程端口&lt;/strong&gt;}&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Stream&lt;/strong&gt; Socket
&lt;ul&gt;
&lt;li&gt;面向连接、可靠&lt;/li&gt;
&lt;li&gt;按顺序接收&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字节流&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Datagram&lt;/strong&gt; Socket
&lt;ul&gt;
&lt;li&gt;无连接&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据报&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;接收顺序不固定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Raw Socket
&lt;ul&gt;
&lt;li&gt;用于检验新的协议的实现&lt;/li&gt;
&lt;li&gt;允许对较低层次的协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;udp&#34;&gt;UDP&lt;/h1&gt;
&lt;p&gt;UDP(User Datagram Protocol)：用户数据报协议，一种以&lt;strong&gt;数据报&lt;/strong&gt;为数据单元&lt;strong&gt;的面向无连接&lt;/strong&gt;的传输层协议。
UDP只提供了&lt;strong&gt;差错检测&lt;/strong&gt;的功能，因此相对&lt;a href=&#34;#TCP&#34;&gt;TCP&lt;/a&gt;速度更快。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;端对端&lt;/li&gt;
&lt;li&gt;不可靠，不需要连接&lt;/li&gt;
&lt;li&gt;面向数据报&lt;/li&gt;
&lt;li&gt;无拥塞控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;udp报头&#34;&gt;UDP报头&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143034.png&#34; alt=&#34;&#34;&gt;
UDP为了能够计算校验和，必须加上伪头部。&lt;/p&gt;
&lt;h2 id=&#34;connect和bind函数&#34;&gt;connect和bind函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;bind：发送端调用 bind 函数时，就会将这个套接字指定一个端口，避免内核执行该操作，提高性能&lt;/li&gt;
&lt;li&gt;connect：记录IP及Port。和普通的 UDP 相比，调用 connect 的 UDP 会提升效率，并且在高并发服务中会增加系统稳定性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;tcp&#34;&gt;TCP&lt;/h1&gt;
&lt;p&gt;TCP(Transmission Control Procotol): 提供以**报文段(Segment)**为数据单元的传输层通信服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向连接&lt;/li&gt;
&lt;li&gt;端对端&lt;/li&gt;
&lt;li&gt;可靠交付&lt;/li&gt;
&lt;li&gt;全双工&lt;/li&gt;
&lt;li&gt;基于字节流&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143035.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;连接过程&#34;&gt;连接过程&lt;/h2&gt;
&lt;p&gt;TCP协议的运行可划分为三个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%9E%E6%8E%A5%E5%88%9B%E5%BB%BA&#34;&gt;连接创建&lt;/a&gt;(connection establishment)&lt;/li&gt;
&lt;li&gt;数据传送（data transfer）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE&#34;&gt;连接释放&lt;/a&gt;（connection termination）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;连接创建&#34;&gt;连接创建&lt;/h3&gt;
&lt;p&gt;TCP用==三次握手==（或称三路握手，three-way handshake）过程创建一个连接。
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143036.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端（通过执行connect函数）向服务器端发送一个SYN包，请求一个主动打开。该包携带客户端为这个连接请求而设定的随机数x作为消息序列号。&lt;/li&gt;
&lt;li&gt;服务器端收到一个合法的SYN包后，把该包放入SYN队列中；回送一个SYN/ACK。ACK的确认码应为x+1，SYN/ACK包本身携带一个随机产生的序号y。&lt;/li&gt;
&lt;li&gt;客户端收到SYN/ACK包后，发送一个ACK包，该包的序号被设定为x+1，而ACK的确认码则为y+1。然后客户端的connect函数成功返回。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;连接释放&#34;&gt;连接释放&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143037.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送FIN包给服务器端，结束 ESTABLISHED 阶段并进入 FIN-WAIT-1 阶段&lt;/li&gt;
&lt;li&gt;服务器端收到客户端的FIN包后发送ACK包给客户端，结束 ESTABLISHED 阶段并进入CLOSE-WAIT 阶段&lt;/li&gt;
&lt;li&gt;客户端收到ACK包后进入FIN-WAIT-2 阶段&lt;/li&gt;
&lt;li&gt;服务器端将数据传送完毕后发送ACK/FIN包给客户端，结束CLOSE-WAIT阶段并进入 LAST-ACK 阶段&lt;/li&gt;
&lt;li&gt;客户端收到ACK/SYN包后进入TIME-WAIT 阶段并发送ACK包给服务器端&lt;/li&gt;
&lt;li&gt;客户端开始在 TIME-WAIT 阶段等待 &lt;strong&gt;2 MSL&lt;/strong&gt;。服务器端收到从客户端发出的 TCP 报文之后结束 LAST-ACK 阶段，进入 CLOSED 阶段。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端等待 2 MSL的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证没有数据包滞留&lt;/li&gt;
&lt;li&gt;确保客户端发的ACK包被服务器端收到（如果服务器端没有收到将认为自己发送的ACK/SYN包没有收到而再次发送）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;计时器&#34;&gt;计时器&lt;/h2&gt;
&lt;p&gt;TCP主要有以下4种计时器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重传计时器：当发送方发送的数据包后一段时间内没有收到对方发送的ACK包则重发该数据包。&lt;/li&gt;
&lt;li&gt;保活计时器：当接收方没有收到对方的数据包一段时间后，将发送一个探测包以检测对方是否正常在线。&lt;/li&gt;
&lt;li&gt;坚持计时器：当接收方收到对方的滑动窗口为0的数据包将停止发送数据包，等待一段时间后将发送一个探测包，避免死锁发生。&lt;/li&gt;
&lt;li&gt;时间等待计时器：在四次挥手中客户端收到ACK/SYN包后开始计时。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除上述四种计时器外，还有FIN_WAIT_2 计时器、延迟应答计时器等等。&lt;/p&gt;
&lt;h2 id=&#34;可靠性&#34;&gt;可靠性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;流量控制——滑动窗口&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;%E4%BC%A0%E8%BE%93%E5%B1%82.md#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6&#34;&gt;拥塞控制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;序列号及应答——确保数据能无重复地达到&lt;/li&gt;
&lt;li&gt;校验和——确保数据在传输的过程中没有发生变化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;拥塞控制&#34;&gt;拥塞控制&lt;/h3&gt;
&lt;p&gt;拥塞窗口（congestion window）：发送方确定能发送出去的字节数的控制因素之一，是阻止发送方至接收方之间的链路变得拥塞的手段。
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143038.png&#34; alt=&#34;&#34;&gt;
慢启动：设置拥塞窗口值（cwnd）为1个MSS，发送方每收到一个ACK包cwnd加1（因此每个RTTcwnd加倍），直到cwnd达到慢开始门限ssthresh值或出现丢包。
拥塞避免：接收方每经过一个RTT，cwnd加1(&lt;strong&gt;加法增大&lt;/strong&gt;)，直到出现丢包。
快恢复（Reno）：当出现丢包时，将ssthresh减半(&lt;strong&gt;乘法减小&lt;/strong&gt;)并cwnd设置为ssthresh减半后的值,然后进入拥塞避免阶段。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时&lt;strong&gt;不执行慢开始&lt;/strong&gt;算法。
在这个过程中还涉及到&lt;a href=&#34;%E4%BC%A0%E8%BE%93%E5%B1%82.md#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6&#34;&gt;快速重传机制&lt;/a&gt;：&lt;strong&gt;接收方&lt;/strong&gt;三次收到同一个失序的报文段后就立即发出重复确认。
&lt;u&gt;注意：“拥塞避免”并非完全能够避免了阻塞，只能尽量避免网络拥塞出现。&lt;/u&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;快速重传机制&#34;&gt;快速重传机制&lt;/h2&gt;
&lt;p&gt;虽然报文段丢失时，由于重传机制，发送端会重传分组，但会等待一定的周期，增加了&lt;strong&gt;端到端的时延&lt;/strong&gt;，而快速重传机制可以有效减少时延。
TCP采用的是累计确认机制，即当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号（冗余ACK，duplicate ACK），告诉接收方发送丢包。
如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK，发送端便会重传该报文段，&lt;u&gt;不需要等待超时重传定时器溢出&lt;/u&gt;
为什么是3次冗余ACK？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号&lt;/strong&gt;，但该报文段不一定已经丢失，也有可能在将来的某个时间到达。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;粘包问题&#34;&gt;粘包问题&lt;/h2&gt;
&lt;p&gt;&lt;u&gt;严格来说，TCP是面向流的协议，不存在“粘包问题”。&lt;/u&gt;
粘包有两种含义&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由于发送方采用Nagle算法，将多个小报文放在一起发送出去。&lt;/li&gt;
&lt;li&gt;接收方一次收到多个应用层报文，即接收方的&lt;a href=&#34;%E5%BA%94%E7%94%A8%E5%B1%82.md&#34;&gt;应用层&lt;/a&gt;来不及处理数据接收方又收到了新的报文。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/leetbook/read/networks-interview-highlights/es7qwj/&#34;&gt;UDP 为什么是不可靠的？bind 和 connect 对于 UDP 的作用是什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/leetbook/read/networks-interview-highlights/esegch/&#34;&gt;三次握手和四次挥手机制- Leetcode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/LF_2016/article/details/60468161&#34;&gt;TCP第四次挥手为什么要等待2MSL-CSDN博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/leetbook/read/networks-interview-highlights/esd47g/&#34;&gt;TCP 协议中的定时器- Leetcode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/LF_2016/article/details/60468100&#34;&gt;TCP使用的四种计时器_Sunnylunch-blog-CSDN博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6&#34;&gt;TCP拥塞控制- 维基百科，自由的百科全书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/37379780&#34;&gt;TCP流量控制、拥塞控制- 知乎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

    </description>
    </item>
    
    <item>
    <title>应用层</title>
    <link>https://example.com/posts/net/%E5%BA%94%E7%94%A8%E5%B1%82/</link>
    <pubDate>Thu, 22 Apr 2021 00:13:24 +0800</pubDate>
    
    <guid>https://example.com/posts/net/%E5%BA%94%E7%94%A8%E5%B1%82/</guid>
    <description>
        &lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;应用层通过不同的应用层协议为不同的应用提供通信服务。
常用协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#HTTP&#34;&gt;HTTP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#HTTPS&#34;&gt;HTTPS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#DNS&#34;&gt;DNS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户输入网址到显示对应页面的全过程:
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143524.png&#34; alt=&#34;100&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;输入网址URL。&lt;/li&gt;
&lt;li&gt;发送到DNS获得域对应的&lt;a href=&#34;%E7%BD%91%E7%BB%9C%E5%B1%82.md&#34;&gt;网络层&lt;/a&gt;地址。&lt;/li&gt;
&lt;li&gt;客户端浏览器与WEB服务器建立&lt;a href=&#34;%E4%BC%A0%E8%BE%93%E5%B1%82.md&#34;&gt;传输层&lt;/a&gt;连接。&lt;/li&gt;
&lt;li&gt;客户端浏览器向对应IP地址的WEB服务器发送相应的&lt;a href=&#34;#HTTP&#34;&gt;HTTP&lt;/a&gt;或&lt;a href=&#34;#HTTPS&#34;&gt;HTTPS&lt;/a&gt;请求。&lt;/li&gt;
&lt;li&gt;WEB服务器响应请求，返回指定的URL数据或错误信息；如果设定重定向，则重定向到新的URL地址。&lt;/li&gt;
&lt;li&gt;客户端浏览器下载数据，解析HTML源文件，在浏览器中显示基础的页面。&lt;/li&gt;
&lt;li&gt;分析页面中的超链接，显示在当前页面。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;http&#34;&gt;HTTP&lt;/h1&gt;
&lt;p&gt;Hyper Text Transfer Protocol(超文本传输协议）
提供HTML(超文本标记语言)的发送和接收方法，一般基于&lt;a href=&#34;%E4%BC%A0%E8%BE%93%E5%B1%82.md&#34;&gt;传输层&lt;/a&gt;/&lt;a href=&#34;%E7%BD%91%E7%BB%9C%E5%B1%82.md&#34;&gt;网络层&lt;/a&gt;通信，使用B/S架构。&lt;/p&gt;
&lt;h2 id=&#34;组成&#34;&gt;组成&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;请求报文
&lt;ol&gt;
&lt;li&gt;请求行&lt;/li&gt;
&lt;li&gt;请求头&lt;/li&gt;
&lt;li&gt;请求正文&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;响应报文
&lt;ol&gt;
&lt;li&gt;状态行&lt;/li&gt;
&lt;li&gt;响应头&lt;/li&gt;
&lt;li&gt;响应报文&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常见请求方法&#34;&gt;常见请求方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;GET：请求指定的信息并返回具体具体内容。&lt;/li&gt;
&lt;li&gt;HEAD：和GET类似，但不返回具体内容。&lt;/li&gt;
&lt;li&gt;POST：在服务器新建资源，数据被包含在请求体中。&lt;/li&gt;
&lt;li&gt;PUT：在服务器更新资源。&lt;/li&gt;
&lt;li&gt;DELETE：请求服务器删除指定的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;POST和GET的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;POST用于提交；GET用于查询。&lt;/li&gt;
&lt;li&gt;GET是直接添加到URL后面的，直接就可以在URL中看到内容；POST是放在报文内部的，用户无法直接看到。&lt;/li&gt;
&lt;li&gt;GET的数据长度有限（因为放在URL后面，URL根据不同的浏览器有不同长度限制）；POST没有长度限制。&lt;/li&gt;
&lt;li&gt;GET只支持URL编码，只支持ASCII字符格式的参数；支持多种编码且对字符格式没有限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;响应状态码&#34;&gt;响应状态码&lt;/h2&gt;
&lt;p&gt;HTTP的响应状态码由3个10进制数组成，第一个数有分类的作用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1xx：指示信息&amp;ndash;表示请求正在处理&lt;/li&gt;
&lt;li&gt;2xx：成功&amp;ndash;表示请求已被成功处理完毕&lt;/li&gt;
&lt;li&gt;3xx：需要重定向&amp;ndash;要完成的请求需要进行附加操作&lt;/li&gt;
&lt;li&gt;4xx：客户端错误&lt;/li&gt;
&lt;li&gt;5xx：服务器错误&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;常见状态码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;200 OK - 客户端请求成功&lt;/li&gt;
&lt;li&gt;301 - 资源（网页等）被永久转移到其它URL&lt;/li&gt;
&lt;li&gt;302 - 临时跳转&lt;/li&gt;
&lt;li&gt;400 - 客户端请求有语法错误，服务器无法识别&lt;/li&gt;
&lt;li&gt;401 - 请求未经授权&lt;/li&gt;
&lt;li&gt;404 - 服务器无法找到对应资源&lt;/li&gt;
&lt;li&gt;500 - 服务器内部错误&lt;/li&gt;
&lt;li&gt;503 - 服务器正忙&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;持久和非持久连接&#34;&gt;持久和非持久连接&lt;/h2&gt;
&lt;p&gt;持久连接：客户端发起第一次请求建立TCP连接之后的一段时间之内，不需要再次建立[[传输层]]连接
非持久连接：每次传输对象都需要建立一次TCP连接。
在 HTTP/1.1 及之后的版本中默认使用持久连接。
注意：持久连接需要配置正确的keep-alive timeout参数，否则可能导致资源被长时间无效占用。&lt;/p&gt;
&lt;h2 id=&#34;如何保存用户状态&#34;&gt;如何保存用户状态&lt;/h2&gt;
&lt;p&gt;HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。常有以下两种解决方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于Session实现的会话保持&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在客户端第一次向服务器发送HTTP请求时，服务器将会话状态保存起来，然后分配一个会话标识（SessionId）给客户端，以后每次浏览器发送HTTP请求都会带上Cookie中的SessionId到服务器，服务器拿到会话标识就可以把之前存储在服务器端的状态信息与会话联系起来，实现会话保持&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;基于Cookie实现的会话保持&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;基于Cookie实现会话保持与上述基于Session实现会话保持的最主要区别是前者完全将会话状态信息存储在浏览器Cookie中，这样一来每次浏览器发送HTTP请求的时候都会带上状态信息，因此也就可以实现状态保持。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;https&#34;&gt;HTTPS&lt;/h1&gt;
&lt;p&gt;Hyper Text Transfer Protocol over Secure Socket Layer
HTTPS和&lt;a href=&#34;%E5%BA%94%E7%94%A8%E5%B1%82.md&#34;&gt;应用层&lt;/a&gt;的最大区别是HTTPS多了一个&lt;a href=&#34;HTTPS.md#SSL%E8%BF%87%E7%A8%8B&#34;&gt;SSL过程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;https的特点&#34;&gt;HTTPS的特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS传输过程是加密的&lt;/li&gt;
&lt;li&gt;服务器需要到CA申请证书&lt;/li&gt;
&lt;li&gt;响应较慢，需要经过一个SSL/TLS&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ssl过程&#34;&gt;SSL过程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143525.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;客户端向服务器发出连接请求，内容包括 SSL 的版本、自身支持的加密算法列表等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器根据客户端的算法类列表选择一种自身支持的算法，将其和其他密钥组件发送给客户端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器向客户端发送第三方数字证书。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数字证书包含颁发机构、网址、公钥、证书有效期等信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端验证数字证书的真实性，如果有问题则出现提示警告；否则根据证书内的公钥使用对称加密算法生成密钥并发给服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器用私钥解密收到的内容得到对称加密的密钥，并用密钥发送内容给客户端。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;dns&#34;&gt;DNS&lt;/h1&gt;
&lt;p&gt;Domain Name System，域名系统
作用：用于将域名转换成IP地址，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。&lt;/p&gt;
&lt;h2 id=&#34;层次结构&#34;&gt;层次结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://pic1.zhimg.com/v2-d4ebb1c03acc11c40aa2d0624e98f9f8_r.jpg&#34; alt=&#34;preview&#34;&gt;
树状结构，从上到下依次为根域名服务器、顶级域名服务器和权威域名服务器等。&lt;/p&gt;
&lt;p&gt;注意：本地local DNS（也叫递归DNS）一般不包含在层次结构中，且不会配置任何数据，其数据均来自权威DNS的查询缓存。
&lt;img src=&#34;https://pic2.zhimg.com/v2-eabb1795b1e3b84a82fc280ba2154639_r.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;解析过程&#34;&gt;解析过程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143526.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端根据要查询的DN想local DNS发起一个解析请求&lt;/li&gt;
&lt;li&gt;若local DNS缓存中有记录，则返回对应的IP，否则local DNS 向DNS层次结构从上到下依次查询并将查询结果发给local DNS，直到查到目标IP。
上述解析过程包含了两种查询方式：递归查询和迭代查询&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/donggx/article/details/71402871&#34;&gt;输入网址到网页显示的过程是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/leetbook/read/networks-interview-highlights/es94bd/&#34;&gt;网页解析全过程【用户输入网址到显示对应页面的全过程】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/88260838&#34;&gt;DNS原理及解析过程详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.csoonline.com/article/3246212/what-is-ssl-tls-and-how-this-encryption-protocol-works.html&#34;&gt;What is SSL, TLS? And how this encryption protocol works&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/36981565&#34;&gt;浅谈SSL/TLS工作原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/72616216&#34;&gt;十分钟搞懂HTTP和HTTPS协议？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/leetbook/read/networks-interview-highlights/ez30qs/&#34;&gt;GET 和 POST 的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/leetbook/read/networks-interview-highlights/eg0dl5/&#34;&gt;Keep-Alive 和非 Keep-Alive 区别，对服务器性能有影响吗&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

    </description>
    </item>
    
    <item>
    <title>数据链路层</title>
    <link>https://example.com/posts/net/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</link>
    <pubDate>Thu, 22 Apr 2021 00:13:24 +0800</pubDate>
    
    <guid>https://example.com/posts/net/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</guid>
    <description>
        &lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;数据链路层提供帧间的逻辑通信服务。
类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点对点信道：也就是字面意思，点对点得通信方式。&lt;/li&gt;
&lt;li&gt;广播信道：这种信道是一对多的方式，所以整个过程也比较复杂。必须使用一些信道协议来协调网络中的主机数据发送。在半双工通信中有&lt;a href=&#34;#CSMA&#34;&gt;CSMA&lt;/a&gt;等协议。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据链路层主要有两个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;差错检测：使用&lt;strong&gt;循环冗余检验&lt;/strong&gt;（CRC）来检查数据传输过程中是否产生比特差错&lt;/li&gt;
&lt;li&gt;流量控制：采用&lt;strong&gt;滑动窗口机制&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;封装帧&#34;&gt;封装帧&lt;/h2&gt;
&lt;p&gt;将&lt;a href=&#34;%E7%BD%91%E7%BB%9C%E5%B1%82.md&#34;&gt;网络层&lt;/a&gt;传下来的分组前后分别添加首部和尾部，这样就构成了帧。
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143311.png&#34; alt=&#34;&#34;&gt;
透明传输：帧使用首部和尾部进行定界。如果帧的数据部分含有和首部和尾部相同的内容，需要插入转义字符。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。&lt;/p&gt;
&lt;h1 id=&#34;mac&#34;&gt;MAC&lt;/h1&gt;
&lt;p&gt;确认网络设备位置的位址。
由48位二进制数组成。一般用12个16进制数代表：
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143312.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;csma&#34;&gt;CSMA&lt;/h1&gt;
&lt;p&gt;CSMA(Carrier Sense Multiple Access): 载波侦听多路访问，&lt;strong&gt;用于半双工通信&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;
&lt;p&gt;LBT机制:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1-persistent CSMA：节点需要持续监听信道，一旦节点发现信道空闲后，则立刻发送数据。&lt;/li&gt;
&lt;li&gt;0-persistent CSMA：节点不连续监听信道，若该时刻节点监听信道为busy，那么等待一段时间后，再次进行监听。若节点该时刻监听信道为空闲，则立刻发送数据。&lt;/li&gt;
&lt;li&gt;p-persistentes CSMA：节点需要持续监听信道，一旦发现信道空闲后，节点以p的概率立刻发送数据，以1-p的概率不发送数据。若节点该时刻不发送数据，那么等待一段时间后，再次进行监听，并以p概率再次发送。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;csmacd&#34;&gt;CSMA/CD&lt;/h2&gt;
&lt;p&gt;Carrier Sense Multiple Access with Collision Detection
CSMA/CD采用的是1-persistent CSMA。
CD: 在传输过程中，若检测到冲突，节点立刻停止当前的传输，并且发送特定的干扰序列用以保证其余所有节点都检测到该次冲突。若检查到冲突，则执行&lt;strong&gt;二进制指数避退算法&lt;/strong&gt;重传（当重传16次之后放弃重传）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;从[0， 2^(k-1) ]从随机选择一个数R，（k=Min[重传次数，10]）&lt;/li&gt;
&lt;li&gt;重传时间为 2T * R（T为单程端到端的传播时延）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意：以太网规定了一个最短帧的长度为64个字节。避免检测到冲突时，数据帧已经传送完毕，无法被撤回。&lt;/p&gt;
&lt;h2 id=&#34;csmaca&#34;&gt;CSMA/CA&lt;/h2&gt;
&lt;p&gt;无线局域网在半双工通信下会遇到以下问题：
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143313.png&#34; alt=&#34;&#34;&gt;
为了缓解该问题，一般使用CSMA/CA协议。CSMA/CA协议主要使用两种方法来避免碰撞：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;帧听到通道空闲时，维持一段帧间隔时间IFS (InterFrame Space)后，再等待一段随机的时间依然空闲时，才提交。
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;SIFS，短帧间间隔，如ACK帧、CTS帧&lt;/li&gt;
&lt;li&gt;DIFS，分布协调功能帧间间隔&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;RTS-CTS三向握手：设备欲发送帧前，先发送一个很小的RTS帧给最近的AP，等待目标端回应CTS帧后，才开始发送。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;过程：当信道为空的时候，首先等待一个帧间间隔，之后再监听信道，如果还为空，那么开始执行回退机制，回退机制之后，再次监听，如果还为空，那么就开始发送。&lt;/p&gt;
&lt;h3 id=&#34;回退机制&#34;&gt;回退机制：&lt;/h3&gt;
&lt;p&gt;竞争窗口（Contention Window）大小 = 2^(k -1)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若传输成功，则k减1。&lt;/li&gt;
&lt;li&gt;若发生冲突后，在1~6次中，k加1翻倍，第6次时，窗口大小不变，若第7次传输失败，则进行丢包处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;后退时间= randomT * 单位时间，randomT是从（0，Cw）中的一个随机数。&lt;/p&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/20731045&#34;&gt;802.11协议精读3：CSMA/CD与CSMA/CA - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/loveCC_orange/article/details/79177129&#34;&gt;CSMA/CD协议详解！！！_loveCC_orange的博客-CSDN博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq894040717/article/details/82426965&#34;&gt;CSMA/CA协议详解【计算机网络】_周末参见-CSDN博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%BD%BD%E6%B3%A2%E4%BE%A6%E5%90%AC%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE&#34;&gt;载波侦听多路访问- 维基百科，自由的百科全书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/hanzhen7541/article/details/79024068&#34;&gt;802.11的CSMA/CA机制_hanzhen7541的博客-CSDN博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/69554474&#34;&gt;【计算机网络】你真的理解数据链路层吗？ - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode-cn.com/leetbook/read/networks-interview-highlights/e4ppa6/&#34;&gt;数据链路层上的三个基本问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

    </description>
    </item>
    
    <item>
    <title>网络层</title>
    <link>https://example.com/posts/net/%E7%BD%91%E7%BB%9C%E5%B1%82/</link>
    <pubDate>Thu, 22 Apr 2021 00:13:24 +0800</pubDate>
    
    <guid>https://example.com/posts/net/%E7%BD%91%E7%BB%9C%E5%B1%82/</guid>
    <description>
        &lt;h1 id=&#34;网络层&#34;&gt;网络层&lt;/h1&gt;
&lt;p&gt;在&lt;a href=&#34;%E4%BC%A0%E8%BE%93%E5%B1%82.md&#34;&gt;传输层&lt;/a&gt;的基础上，提供主机到主机之间的&lt;strong&gt;逻辑通信&lt;/strong&gt;服务。&lt;/p&gt;
&lt;p&gt;网络层包含有&lt;a href=&#34;#IP&#34;&gt;IP&lt;/a&gt;，&lt;a href=&#34;#ICMP&#34;&gt;ICMP&lt;/a&gt;，&lt;a href=&#34;#ARP&#34;&gt;ARP&lt;/a&gt;等协议。&lt;/p&gt;
&lt;h1 id=&#34;ip&#34;&gt;IP&lt;/h1&gt;
&lt;p&gt;IP(Internet Protocol)：提供&lt;strong&gt;无连接&lt;/strong&gt;的**分组(packet)**通信服务，不能保证分组可靠的、按序到达。&lt;/p&gt;
&lt;h2 id=&#34;ip分组结构&#34;&gt;IP分组结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143501.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;版本：4位，表示IP协议版本，通常为0100（v4），若为0110则表示为v6版&lt;/li&gt;
&lt;li&gt;区分服务：8位，以前称为服务类型，从未使用过。1998年改称区分服务。用于指明要求网络提供的服务，目前主要包括D、T、R等三种，分别代表延迟、吞吐量和可靠性要求。&lt;/li&gt;
&lt;li&gt;总长度：16位，包括了首部长度和数据长度。&lt;/li&gt;
&lt;li&gt;标识：16位，数据报计数器，用于区分数据报的唯一标识符。&lt;/li&gt;
&lt;li&gt;标志：3 位，最高位保留；中间位是不分片（Don‘t Fragment，DF）标志，DF=1则不允许分片。最低位是有更多分片（More Fragment，MF）标志，除最后一个分片MF=0以外外其余都是MF=1。&lt;/li&gt;
&lt;li&gt;片偏移：13 位，表示分片后，该片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。&lt;/li&gt;
&lt;li&gt;生存时间：8 位，表示数据报在网络中可通过的路由器数的最大值。若超出最大值，则丢弃数据包，并返回“目标不可达”。&lt;/li&gt;
&lt;li&gt;协议：8位，指出此数据报使用何种协议。如&lt;a href=&#34;ICMP.md&#34;&gt;ICMP&lt;/a&gt;协议&lt;/li&gt;
&lt;li&gt;首部检验和：16位，只检验数据报首部。&lt;/li&gt;
&lt;li&gt;源地址：32位，发送端主机IP地址。&lt;/li&gt;
&lt;li&gt;目的地址：32位，接收端主机IP地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分类ip地址&#34;&gt;分类IP地址&lt;/h2&gt;
&lt;p&gt;IP地址被分为五类，分别称为A类、B类、C类、D类和E类：
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143502.png&#34; alt=&#34;&#34;&gt;
A、B和C类地址分别有两个固定长度的字段组成，其中一个字段是网络号（net-id），表示联网主机（或网络设备）所在的网络，另一个字段是主机号（host-id），表示联网主机（或网络设备）本身。&lt;strong&gt;D类和E类地址不区分网络和主机。&lt;/strong&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143503.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;划分子网ip地址&#34;&gt;划分子网IP地址&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143504.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将一个IP类网划分成几个较小的子网（subnet）&lt;/li&gt;
&lt;li&gt;多个物理网共享同一个IP类网前缀&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;==即，子网划分就是在32位中借了几位用来表示子网号。==
用==子网掩码==分离网络号和主机号：
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143505.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;特殊地址&#34;&gt;特殊地址&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;host-id全为“1”的地址：本子网内的&lt;strong&gt;广播地址&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;host-id为零的IP地址表示该&lt;strong&gt;网络本身&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;保留地址&#34;&gt;保留地址&lt;/h2&gt;
&lt;p&gt;保留地址：又称为私网地址，各独立网络可以重复使用的IP地址。网络边界路由器（通常就是网关）不会向目标地址为这些保留地址的主机转发IP分组。也就是说，保留地址不会穿越内部网络。==即只在局域网内使用==。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A类：10.0.0.0 （1个网络）
B类：172.16.0.0—172.31.0.0（16个网络）
C类：192.168.0.0—192.168.255.0（256个网络）
注意：当采用静态或者动态转换时，一个保留地址对应一个公网地址；而采用端口复用的方式，在一个子网中的所有地址都采用一个公网地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;cidr&#34;&gt;CIDR&lt;/h2&gt;
&lt;p&gt;Classless Inter-Domain Routing
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143506.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;特点&#34;&gt;特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;斜线记法&lt;/li&gt;
&lt;li&gt;CIDR 地址块&lt;/li&gt;
&lt;li&gt;聚合-&amp;gt;超网(supernetting)&lt;/li&gt;
&lt;li&gt;最长前缀匹配原则&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;icmp&#34;&gt;ICMP&lt;/h1&gt;
&lt;p&gt;ICMP(Internet Control Message Protocol)：当&lt;a href=&#34;#IP&#34;&gt;IP&lt;/a&gt;丢包时向传输层报告丢包以及丢包的原因。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于&lt;a href=&#34;#IP&#34;&gt;IP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;需要经过&lt;strong&gt;两次封装&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结构&#34;&gt;结构&lt;/h2&gt;
&lt;p&gt;报头：
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143507.png&#34; alt=&#34;&#34;&gt;
数据：
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143508.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;应用&#34;&gt;应用&lt;/h2&gt;
&lt;h3 id=&#34;ping&#34;&gt;Ping&lt;/h3&gt;
&lt;p&gt;Ping(Packet InterNet Groper)：用来测试两个主机之间的连通性。&lt;/p&gt;
&lt;p&gt;过程：源主机向目的主机发送Echo Request，目的主机收到之后进行响应，回复Echo reply。
Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率从而推断网络是否通常、运行是否正常等。&lt;/p&gt;
&lt;p&gt;注意：PING 是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP。&lt;/p&gt;
&lt;h3 id=&#34;tracert&#34;&gt;Tracert&lt;/h3&gt;
&lt;p&gt;Tracert 命令用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由，是实现路由追踪（trace router）的一种手段。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先tracert送出3个TTL是1的IP 数据包到目的地，当路径上的第一个路由器收到这个数据包时，它将TTL减1，此时TTL等于0.&lt;/li&gt;
&lt;li&gt;所以该路由器会将此数据包丢掉，并送回一个**ICMP time exceeded ** 消息（TTL超时消息），里面包括发IP包的源地址，IP包的所有内容及路由器的IP地址&lt;/li&gt;
&lt;li&gt;tracert 收到这个消息后，便知道这个路由器存在于这个路径上，接着tracert 再送出另一个TTL是2 的数据包，发现第2 个路由器&amp;hellip;..以此类推&lt;/li&gt;
&lt;li&gt;当数据包到达目的地后，该主机则不会送回 &lt;strong&gt;ICMP time exceeded&lt;/strong&gt; 消息&lt;/li&gt;
&lt;li&gt;一旦到达目的地，由于tracert通过UDP数据包向不常见端口(30000以上)发送数据包，因此会收到 ICMP port unreachable 消息，故可判断到达目的地。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;arp&#34;&gt;ARP&lt;/h1&gt;
&lt;p&gt;ARP(Address Resolution Protocol)：将IP地址转换成&lt;a href=&#34;%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.md#MAC&#34;&gt;MAC&lt;/a&gt;地址。&lt;/p&gt;
&lt;h2 id=&#34;以太帧格式&#34;&gt;以太帧格式&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143509.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;硬件类型：如以太网（0x0001）、分组无线网。
协议类型：如网际协议(IP)（0x0800）、IPv6（0x86DD）。
硬件地址长度：每种硬件地址的字节长度，一般为6（以太网）。
协议地址长度：每种协议地址的字节长度，一般为4（IPv4）。
操作码：1为ARP请求，2为ARP应答，3为RARP请求，4为RARP应答。
源硬件地址：n个字节，n由硬件地址长度得到，一般为发送方MAC地址。
源协议地址：m个字节，m由协议地址长度得到，一般为发送方IP地址。
目标硬件地址：n个字节，n由硬件地址长度得到，一般为目标MAC地址。
目标协议地址：m个字节，m由协议地址长度得到，一般为目标IP地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;arp原理&#34;&gt;ARP原理&lt;/h2&gt;
&lt;p&gt;主机里有一个ARP缓存表，表里的IP地址与MAC地址一一对应：
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143510.png&#34; alt=&#34;&#34;&gt;
以主机A向主机B发送数据为例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果B主机的IP地址存在于缓存表中，则A主机将对应的MAC地址写入帧发送给B主机。&lt;/li&gt;
&lt;li&gt;如果在ARP缓存表中没有找到相对应的IP地址，主机A就会在网络上发送一个广播（ARP request），以询问对方的MAC地址；&lt;strong&gt;只有&lt;/strong&gt;主机B接收到这个帧时，才向主机A发出以单播方式的回应（ARP response），并将A的IP和MAC地址保存到B的缓存表里面。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ARP缓存表采用老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可减少缓存表的长度，加快查询速度。并且，如果电脑或者通信设备重启的话，这张表也会清空。&lt;/p&gt;
&lt;h2 id=&#34;gratuitous-arp&#34;&gt;gratuitous ARP&lt;/h2&gt;
&lt;p&gt;主机发送ARP查询（广播）自己的IP地址，当ARP功能被开启或者是端口初始配置完成，主机向网络发送免费ARP来查询自己的IP地址确认地址唯一可用。
作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定网络中是否有其他主机使用了IP地址，如果有应答则产生错误消息。&lt;/li&gt;
&lt;li&gt;免费ARP可以&lt;strong&gt;更新ARP的缓存&lt;/strong&gt;，网络中的其他主机收到该广播则在缓存中更新条目，收到该广播的主机无论是否存在与IP地址相关的条目都会强制更新，如果存在旧条目则会将MAC更新为广播包中的MAC。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;arp攻击&#34;&gt;ARP攻击&lt;/h2&gt;
&lt;p&gt;利用攻击主机收到被攻击主机的广播时，虽然攻击主机不是目标主机，但却欺骗发送主机，将自己的IP改为目标主机的IP，并向被攻击主机发出回应，当回应的频率达到一定要求（能够覆盖真正目标主机发出的回应），便可以完成ARP攻击。&lt;/p&gt;

    </description>
    </item>
    
    <item>
    <title>Dynamic Scheduling</title>
    <link>https://example.com/posts/cpu/dynamic-scheduling/</link>
    <pubDate>Mon, 19 Apr 2021 00:13:24 +0800</pubDate>
    
    <guid>https://example.com/posts/cpu/dynamic-scheduling/</guid>
    <description>
        &lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;Dynamic Scheduling（动态调度）：在&lt;strong&gt;程序的执行过程&lt;/strong&gt;中，依靠专门&lt;strong&gt;硬件&lt;/strong&gt;对代码进行调度，减少&lt;a href=&#34;Dependence.md#Data%20Dependence&#34;&gt;Data Dependence&lt;/a&gt;导致的停顿。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;静态调度: 依靠编译器在&lt;strong&gt;编译期间&lt;/strong&gt;把相关的指令&lt;strong&gt;拉开距离&lt;/strong&gt;来减少可能产生的停顿&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;limitation: In-order Issue（按序流出）、 In-order Execution（按序执行）
solution: Out-of-order Execution（乱序执行）
为了能够乱序执行 ，将 5 段流水线的译码(ID)阶段再分为两个阶段：
&lt;img src=&#34;../pic/Pasted%20image%2020210418114934.png&#34; alt=&#34;525&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;流出（Issue, IS）&lt;/strong&gt;：指令译码，检查是否存在结构冲突。（in-order	issue)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读操作数（Read Operands, RO）&lt;/strong&gt;：等待数据冲突消失，然后读操作数。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;动态调度让指令&lt;strong&gt;乱序完成(Out-of-order Completion)&lt;/strong&gt;，会大大增加异常处理的难度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态调度需要保持正确的异常行为，但动态调度处理机仍可能发生不精确异常，使得在异常处理后难以接着继续执行程序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不精确异常：指令发送异常时，流水线可能已经执行完该指令之后的指令或没有执行完该指令之前的指令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;scoreboard&#34;&gt;Scoreboard&lt;/h1&gt;
&lt;p&gt;记分板（scoreboard）负责管理指令的流出和执行，包括检查&lt;a href=&#34;Dependence.md&#34;&gt;Dependence&lt;/a&gt;。
&lt;img src=&#34;../pic/Pasted%20image%2020210418120446.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;steps&#34;&gt;Steps&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Issue
The scoreboard issues the instruction &lt;strong&gt;only when&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a functional unit for the instruction is &lt;strong&gt;free&lt;/strong&gt;(structural hazards)&lt;/li&gt;
&lt;li&gt;no other active instruction  has the same destination register(avoid &lt;a href=&#34;Dependence.md#WAW&#34;&gt;WAW&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;==Otherwise,  the scoreboard stalls the instruction.==and no further instructions will issue &lt;u&gt;until these hazards are cleared (in-order issue).&lt;/u&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Read operands
The scoreboard issues the instruction &lt;strong&gt;only when&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;All sources operand&lt;/strong&gt; is available, which mean no &lt;strong&gt;earlier issued active instruction&lt;/strong&gt; is going  to write them(avoid &lt;a href=&#34;Dependence.md#RAW&#34;&gt;RAW&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;==Otherwise,  the scoreboard stalls the instruction.==
After issuing, the  scoreboard tells the functional unit to proceed to read the operands from the  registers and begin execution.&lt;/p&gt;
&lt;p&gt;&lt;u&gt;	Instructions may be sent into execution &lt;strong&gt;out of order&lt;/strong&gt;.&lt;/u&gt;(只是stall该条指令，不会因此stall别的指令)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Execution
The functional unit begins execution upon receiving operands. When the result is ready, it **notifies the scoreboard **that it has completed execution.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Write result
Once the scoreboard is aware that the functional unit has completed execution, it writes results to destinaton oprands &lt;strong&gt;only when&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;earlier issued active instruction&lt;/strong&gt; don&amp;rsquo;t need to read **one of the destinaton oprands ** (avoid &lt;a href=&#34;Dependence.md#WAR&#34;&gt;WAR&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;==Otherwise,  the scoreboard stalls the instruction.==&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;implement&#34;&gt;Implement&lt;/h2&gt;
&lt;p&gt;To implement the &lt;a href=&#34;#Steps&#34;&gt;Steps&lt;/a&gt;, scoreboard have 3 tables to record status:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Instruction status: which of 4 &lt;a href=&#34;#Steps&#34;&gt;steps&lt;/a&gt; the instruction is in
&lt;img src=&#34;../pic/Pasted%20image%2020210418145608.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Functional unit status
&lt;img src=&#34;../pic/Pasted%20image%2020210418145619.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Busy: Indicates whether the unit is busy or not&lt;/li&gt;
&lt;li&gt;Op: Operation to perform in the unit (e.g., + or –)&lt;/li&gt;
&lt;li&gt;Fi: Destination register&lt;/li&gt;
&lt;li&gt;Fj, Fk: Source-register numbers&lt;/li&gt;
&lt;li&gt;Qj, Qk: Functional units producing source registers Fj, Fk&lt;/li&gt;
&lt;li&gt;Rj, Rk: Flags indicating when Fj, Fk are ready&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Register result status
&lt;img src=&#34;../pic/Pasted%20image%2020210418145655.png&#34; alt=&#34;&#34;&gt;
Indicates which functional unit will write each register, if one exists.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;limitations&#34;&gt;Limitations&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Number, types, and speed of the functional units
&lt;ul&gt;
&lt;li&gt;This determines how often a structural hazard results in stall.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;没有实现 &lt;a href=&#34;Dependence.md#Data%20Forwarding&#34;&gt;Data Forwarding&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;没有完全解决&lt;a href=&#34;Dependence.md#Data%20Dependence&#34;&gt;Data Dependence&lt;/a&gt;，只是通过简单的stall。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ece-research.unm.edu/jimp/611/slides/chap4_3.html&#34;&gt;Dynamic Scheduling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jianhua Li-College of Computer and Information-Hefei University of Technology-08-Exploiting ILP&lt;/li&gt;
&lt;/ul&gt;

    </description>
    </item>
    
    <item>
    <title>Dependence</title>
    <link>https://example.com/posts/cpu/dependence/</link>
    <pubDate>Sun, 18 Apr 2021 00:13:24 +0800</pubDate>
    
    <guid>https://example.com/posts/cpu/dependence/</guid>
    <description>
        &lt;p&gt;&lt;strong&gt;Dependences&lt;/strong&gt; dictate ordering requirements between instructions.Also called &lt;strong&gt;Hazards&lt;/strong&gt;
Two types:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;Dependence.md#Data%20Denpendence&#34;&gt;Data Dependence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;Dependence.md#Control%20Dependence&#34;&gt;Control Dependence&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;data-dependence&#34;&gt;Data Dependence&lt;/h1&gt;
&lt;p&gt;Types of data dependences&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;Dependence.md#RAW&#34;&gt;RAW&lt;/a&gt;(Flow dependence)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;Dependence.md#WAW&#34;&gt;WAW&lt;/a&gt;(Output dependence)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;Dependence.md#WAR&#34;&gt;WAR&lt;/a&gt;(Anti dependence)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Flow dependence also called true dependence, and output dependence and anti dependence are called Name Dependence.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;raw&#34;&gt;RAW&lt;/h2&gt;
&lt;p&gt;read after write, also called Flow dependence
B tries to read a register before A has written it and gets the old value.
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424155155.png&#34; alt=&#34;600&#34;&gt;
This is common, and &lt;a href=&#34;Dependence.md#Data%20Forwarding&#34;&gt;Data Forwarding&lt;/a&gt; helps to solve it.&lt;/p&gt;
&lt;h2 id=&#34;waw&#34;&gt;WAW&lt;/h2&gt;
&lt;p&gt;write after write, also called Output dependence.
B tries to write an operand before A has written it.
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424155156.png&#34; alt=&#34;600&#34;&gt;
After instruction B has executed, the value of the register should be B&amp;rsquo;s result, but A&amp;rsquo;s result is stored instead.&lt;/p&gt;
&lt;p&gt;This can only happen with pipelines that write values in more than one stage, or in variable-length pipelines (i.e. FP pipelines).&lt;/p&gt;
&lt;h2 id=&#34;war&#34;&gt;WAR&lt;/h2&gt;
&lt;p&gt;write after read, also called Anti dependence
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424155157.png&#34; alt=&#34;600&#34;&gt;
In this case, A uses the new (incorrect) value.&lt;/p&gt;
&lt;p&gt;This type of hazard is rare because most pipelines read values early and write results late.&lt;/p&gt;
&lt;h2 id=&#34;simple-soultion&#34;&gt;Simple soultion&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424155158.png&#34; alt=&#34;600&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;write-in-frist&#34;&gt;Write in frist&lt;/h3&gt;
&lt;p&gt;Write the register file in the first half of the cycle and read it in the second half.
&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424155159.png&#34; alt=&#34;600&#34;&gt;
Fixes the hazard shown in green.&lt;/p&gt;
&lt;h3 id=&#34;data-forwarding&#34;&gt;Data Forwarding&lt;/h3&gt;
&lt;p&gt;Also called &lt;strong&gt;Data Bypassing&lt;/strong&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Allow the CPU to move a value directly from one instruction to another without going through the register file.&lt;/li&gt;
&lt;li&gt;Feeding back the data values from the pipeline registers to the inputs of functional units(future instructions) behind them in the datapath.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424155200.png&#34; alt=&#34;600&#34;&gt;
Fixes the hazard shown in green.&lt;/p&gt;
&lt;h3 id=&#34;stall&#34;&gt;Stall&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;Dependence.md#Data%20Forwarding&#34;&gt;Data Forwarding&lt;/a&gt; helps Loads, but it does NOT solve all the problems: Forwarding helps Loads, but it does NOT solve all the problems.!
&lt;a href=&#34;../pic/Pasted%20image%2020210417231439.png&#34;&gt;&lt;/a&gt;
talling is necessary in this case for proper execution until the hazard is cleared.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Insert a bubble into the pipeline also be right.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;control-dependence&#34;&gt;Control Dependence&lt;/h1&gt;
&lt;p&gt;All instructions are control dependent on previous ones.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The fetched instruction is a non-control-flow instruction, which the next Fetch PC is the address of the &lt;strong&gt;next-sequential&lt;/strong&gt; instruction.&lt;/li&gt;
&lt;li&gt;The instruction that is fetched is &lt;strong&gt;a control-flow instruction&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Stall&lt;/strong&gt; the pipeline until we know the next fetch address&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Branch prediction&lt;/strong&gt;: Guess the next fetch address&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Branch delay slot&lt;/strong&gt;: Instruction Scheduling&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ece-research.unm.edu/jimp/611/slides/chap3_3.html&#34;&gt;Pipelines Hazards&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jianhua Li-College of Computer and Information-Hefei University of Technology-06-Pipeling &amp;amp; Hazards&lt;/li&gt;
&lt;li&gt;Jianhua Li-College of Computer and Information-Hefei University of Technology-07-Dependence Handling&lt;/li&gt;
&lt;/ul&gt;

    </description>
    </item>
    
  </channel>
</rss>
